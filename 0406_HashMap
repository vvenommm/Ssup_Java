package j_collection;

import java.util.Date;
import java.util.HashMap;
import java.util.Set;

public class HashMapClass {

	public static void main(String[] args) {
		/*
		 * Object put(Object key, object value) : 저장된 키와 값을 저장
		 * Object remove(Object key) : 지정된 키로 저장된 값을 제거
		 * Object get(Object key) : 지정된 키의 값(없으면 null)을 반환
		 * Set keySet() : 저장된 모든 키를 Set으로 반환
		 */

		HashMap<String, Object> map = new HashMap<String, Object>();
		//스트링 타입 많이 사용
		
		map.put("age",  10); //put으로 값 저장
		map.put("name",  "홍길동");
		map.put("date",  new Date());
		System.out.println(map); //hash map은 인덱스가 없기 때문에 순서가 존재하지 않음
		
		System.out.println("---------------------------------------------------");
		
		map.put("name",  "이순신"); // 기존의 것을 덮어씀. 가장 마지막의 덮어쓴 값이 남게 됨
		System.out.println(map); //이순신으로 바뀌어 있음
		
		System.out.println("---------------------------------------------------");
		
		map.remove("age");
		System.out.println(map); //age 사라짐
		
		System.out.println("---------------------------------------------------");
		
		Object value = map.get("name"); //제네릭으로 지정했던 타입으로 리턴. 제일 첫 줄 <String, Object>부분
		System.out.println(value);
		
		System.out.println("---------------------------------------------------");
		
		//꺼냈을 때(리턴) Object 타입이라 뭘 어떻게 할 수 없음. 실제 객체는 String이나 Object 타입의 변수에 들어있음.
		//String 클래스에 존재하는 메소드를 사용할 수 없음. 타입이 Object니까
		//다형성 때문에 Object 클래스 안에 있는 메소드만 사용 가능한 상태
		
//		value.substring(1,2); //Object라서 String의 메소드를 사용할 수 없음
//		(String)value.substring(1,2); // 딱 이만큼만 String으로 형변환 하는거라 이렇게 쓰면 안 되고
		((String)value).substring(1,2); //아예 형변환을 싹 시켜주고 실행
		String str = (String)map.get("name"); //혹은 이렇게 형변환. 타입이 확실할 때에 사용
		
		
		//keySet
		Set<String> keys = map.keySet(); //set은 같은 값이 저장되지 않음
		//set의 문제점. get이 존재하지 않아서 값은 하나씩 꺼낼 수 없음
		//iterator를 사용해도 되지만 굳이..?
		
		//향상된 for문. iterator보다 간편
		for(String key : keys) { //콜론 앞 = 값을 저장할 변수, 콜론 뒤 : 순서가 있는 배열같은 것(배열, Array List, Set 등)
			System.out.println(key + " : " + map.get(key));
		}
		
		
		
		
		
		
		
	}

}
